<html xmlns:v="urn:schemas-microsoft-com:vml"
xmlns:o="urn:schemas-microsoft-com:office:office"
xmlns:w="urn:schemas-microsoft-com:office:word"
xmlns="http://www.w3.org/TR/REC-html40">

<head>
<meta http-equiv=Content-Type content="text/html; charset=windows-1251">
<meta name=ProgId content=Word.Document>
<meta name=Generator content="Microsoft Word 11">
<meta name=Originator content="Microsoft Word 11">
<link rel=File-List href="6%20СТРОКИ.files/filelist.xml">
<link rel=Edit-Time-Data href="6%20СТРОКИ.files/editdata.mso">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title>6. Строки</title>
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>user</o:Author>
  <o:Template>Normal</o:Template>
  <o:LastAuthor>user</o:LastAuthor>
  <o:Revision>3</o:Revision>
  <o:TotalTime>1</o:TotalTime>
  <o:Created>2011-03-30T14:03:00Z</o:Created>
  <o:LastSaved>2011-04-04T06:56:00Z</o:LastSaved>
  <o:Pages>1</o:Pages>
  <o:Words>1128</o:Words>
  <o:Characters>6432</o:Characters>
  <o:Lines>53</o:Lines>
  <o:Paragraphs>15</o:Paragraphs>
  <o:CharactersWithSpaces>7545</o:CharactersWithSpaces>
  <o:Version>11.5703</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:SpellingState>Clean</w:SpellingState>
  <w:GrammarState>Clean</w:GrammarState>
  <w:PunctuationKerning/>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:Compatibility>
   <w:BreakWrappedTables/>
   <w:SnapToGridInCell/>
   <w:WrapTextWithPunct/>
   <w:UseAsianBreakRules/>
   <w:DontGrowAutofit/>
  </w:Compatibility>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Font Definitions */
 @font-face
	{font-family:"Lucida Console";
	panose-1:2 11 6 9 4 5 4 2 2 4;
	mso-font-charset:204;
	mso-generic-font-family:modern;
	mso-font-pitch:fixed;
	mso-font-signature:-2147482993 6144 0 0 31 0;}
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0cm;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:12.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h1
	{mso-style-next:Обычный;
	margin-top:12.0pt;
	margin-right:0cm;
	margin-bottom:3.0pt;
	margin-left:0cm;
	mso-pagination:widow-orphan;
	page-break-after:avoid;
	mso-outline-level:1;
	font-size:16.0pt;
	font-family:Arial;
	mso-font-kerning:16.0pt;}
span.H1
	{mso-style-name:"_H1 Знак";
	mso-style-locked:yes;
	mso-style-parent:"";
	mso-style-link:_H1;
	mso-ansi-font-size:20.0pt;
	mso-bidi-font-size:20.0pt;
	text-transform:uppercase;
	mso-ansi-language:RU;
	mso-fareast-language:RU;
	mso-bidi-language:AR-SA;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.H10, li.H10, div.H10
	{mso-style-name:_H1;
	mso-style-parent:"Заголовок 1";
	mso-style-link:"_H1 Знак";
	margin-top:18.0pt;
	margin-right:0cm;
	margin-bottom:18.0pt;
	margin-left:0cm;
	text-align:center;
	page-break-before:always;
	mso-pagination:no-line-numbers;
	mso-outline-level:1;
	font-size:20.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";
	text-transform:uppercase;
	font-weight:bold;
	mso-bidi-font-weight:normal;}
p.P, li.P, div.P
	{mso-style-name:_P;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:justify;
	text-indent:35.45pt;
	mso-pagination:none;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
p.IMG, li.IMG, div.IMG
	{mso-style-name:_IMG;
	margin:0cm;
	margin-bottom:.0001pt;
	text-align:center;
	mso-pagination:none;
	font-size:14.0pt;
	mso-bidi-font-size:10.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
span.Code
	{mso-style-name:_Code;
	mso-style-parent:"";
	mso-ansi-font-size:12.0pt;
	mso-bidi-font-size:12.0pt;
	font-family:"Lucida Console";
	mso-ascii-font-family:"Lucida Console";
	mso-hansi-font-family:"Lucida Console";}
span.SpellE
	{mso-style-name:"";
	mso-spl-e:yes;}
span.GramE
	{mso-style-name:"";
	mso-gram-e:yes;}
@page Section1
	{size:595.3pt 841.9pt;
	margin:2.0cm 42.5pt 2.0cm 3.0cm;
	mso-header-margin:35.4pt;
	mso-footer-margin:35.4pt;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Обычная таблица";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0cm 5.4pt 0cm 5.4pt;
	mso-para-margin:0cm;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:10.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]--><!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="2050"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->
</head>

<body lang=RU style='tab-interval:35.4pt'>

<div class=Section1>

<p class=H10 style='mso-outline-level:2'><a name="_Toc263373083"></a><a
name="_Toc265340312"></a><a name="_Toc266272272"><span style='mso-bookmark:
_Toc265340312'><span style='mso-bookmark:_Toc263373083'>6. Строки</span></span></a></p>

<p class=P>В практике программирования очень часто возникает задача хранения и
использования текстовых строк. При помощи таблиц кодировки группе чисел (байт)
без труда можно поставить в соответствие группу символов (букв). Но сами по себе
строки довольно сложны для представления в компьютерной технике ввиду того, что
их длина неизбежно должна быть переменной. Существует два простых способа
хранения строк в памяти, основанных на использовании <b style='mso-bidi-font-weight:
normal'>статических</b> структур: строки с <i style='mso-bidi-font-style:normal'>упреждающей
длиной</i> и с <i style='mso-bidi-font-style:normal'>завершающим терминальным
элементом</i>. Т.к. размер области в <span class=GramE>памяти</span> отведенной
для хранения строки должен быть <b style='mso-bidi-font-weight:normal'>постоянным</b>,
необходимо иметь способ определять её реальную длину.</p>

<p class=P>В строках с <i style='mso-bidi-font-style:normal'>упреждающей длиной
</i>в памяти перед областью, байты которой интерпретируются как символы строки,
находится число, определяющее реальную длину строки. Именно такой метод
используется в языке <span lang=EN-US style='mso-ansi-language:EN-US'>Pascal</span>
для хранения переменных типа <span lang=EN-US style='mso-ansi-language:EN-US'>string</span>.
Там для строковой переменной по умолчанию отводилось 256 байт в памяти. Первый
байт хранил реальную длину строки, а остальные – её символы. Именно с тем, что
для хранения реальной длины использовался один байт и связано ограничение на
максимальную длину строки в <span lang=EN-US style='mso-ansi-language:EN-US'>Pascal</span>’е.</p>

<p class=P>В языке Си вообще нет встроенного строкового типа. Это, равно как и
отсутствие булевых переменных, вероятнее всего, объясняется историческими
причинами. Однако среди <span class=GramE>встроенных</span> имеются функции,
делающие простой и удобной работу со строками с <i style='mso-bidi-font-style:
normal'>завершающим терминальным элементом</i>. В строках этого типа об
окончании строки свидетельствует специальная (в общем случае)
последовательность символов, <span class=SpellE>котороя</span> называется
терминальной. <span class=GramE>Так, в Си терминальным служит символ с кодом 0
(байт 0<span lang=EN-US style='mso-ansi-language:EN-US'>x</span>00).</span></p>

<p class=P>В виду того, что специального строкового типа нет, а Си-строка
является массивом элементов типа <span lang=EN-US style='mso-ansi-language:
EN-US'>char</span>, логично при хранении строк использовать тип <span
lang=EN-US style='mso-ansi-language:EN-US'>char</span>* (или <span lang=EN-US
style='mso-ansi-language:EN-US'>char</span> [], что, в сущности, то же самое).</p>

<p class=P>Строковый литерал (в двойных кавычках), встретившийся в тексте
программы, помещается компилятором в сегмент данных, в виде массива символов с
завершающим нулем, имеет тип <span lang=EN-US style='mso-ansi-language:EN-US'>char</span>*
и равен адресу в сегменте данных, по которому расположен массив. Ввиду того,
что адрес этот является для компилятора константой, известной во время
компиляции, становится возможным такое выражение:</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>char</span></span></span><span
class=Code><span style='font-size:12.0pt'> *<span class=SpellE>str</span> = “<span
class=SpellE>Hello</span> <span class=SpellE>world</span>”;<o:p></o:p></span></span></p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P style='text-indent:0cm'>или <span class=GramE>аналогичное</span> ему</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>char</span></span></span><span
class=Code><span style='font-size:12.0pt'> <span class=SpellE>str</span>[] =
“Строка”;<o:p></o:p></span></span></p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P>(разница будет заключаться в том, что в первом случае переменную <span
class=SpellE><span lang=EN-US style='mso-ansi-language:EN-US'>str</span></span>
можно будет изменить (как указатель), а во втором нельзя (имя массива)),
однако, если написать так</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>
*const <span class=SpellE>str</span> = “Hello world”;<o:p></o:p></span></span></p>

<p class=P><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=P style='text-indent:0cm'>то и это отличие исчезает.</p>

<p class=P>В общем случае, существует еще два способа создания строковой
переменной: создание массива или динамическое выделение памяти под массив, в
котором можно будет хранить строки, длина которых не больше длины массива.</p>

<p class=P>Первый способ:</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>#<span class=SpellE>include</span>
&lt;<span class=SpellE>string.h</span>&gt;<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>char</span></span></span><span
class=Code><span style='font-size:12.0pt'> <span class=SpellE>str</span>[100];<span
style='mso-spacerun:yes'>         </span>// Любые строки до 99 символов<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>strcpy</span></span></span><span
class=Code><span style='font-size:12.0pt'>(<span class=SpellE>str</span>,
“Строка”); // <span class=SpellE>Побайтое</span> копирование строки<o:p></o:p></span></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Второй</span><span style='mso-ansi-language:
EN-US;mso-no-proof:yes'> </span><span style='mso-no-proof:yes'>способ</span><span
lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:yes'>:<o:p></o:p></span></p>

<p class=P><span lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> *<span
class=SpellE>str</span>;<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=GramE><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>str</span></span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> =
(char*) <span class=SpellE>malloc</span>(100);<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=GramE><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>strcpy</span></span></span></span><span
class=GramE><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>(</span></span></span><span class=SpellE><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>str</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>,
“</span></span><span class=Code><span style='font-size:12.0pt'>Строка</span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>”);<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>free(</span></span></span><span
class=SpellE><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>str</span></span></span><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>);<o:p></o:p></span></span></p>

<p class=P><span lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Использованная стандартная функция </span><span
lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:yes'>strcpy</span><span
style='mso-no-proof:yes'> копирует строку по адресу </span><span class=SpellE><span
class=Code><span style='font-size:12.0pt'>src</span></span></span><span
style='mso-no-proof:yes'>, в строку по адресу </span><span class=SpellE><span
class=Code><span style='font-size:12.0pt'>dest</span></span></span><span
style='mso-no-proof:yes'>, и возвращает указатель </span><span class=SpellE><span
class=Code><span style='font-size:12.0pt'>dest</span></span></span><span
style='mso-no-proof:yes'>:<o:p></o:p></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>// </span></span><span class=Code><span
style='font-size:12.0pt'>Прототип</span></span><span class=Code><span
style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>функции</span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>strcpy</span><o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>strcpy</span>(char* <span class=SpellE>dest</span>, const char* <span
class=SpellE>src</span>);<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>buf</span>[15] = “<span class=SpellE>BufString</span>”;<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>str</span>* = “String”;<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>strcpy</span></span></span><span
class=Code><span style='font-size:12.0pt'>(<span class=SpellE>buf</span>, <span
class=SpellE>str</span>);<o:p></o:p></span></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=IMG><span style='mso-no-proof:yes'><!--[if gte vml 1]><v:shapetype
 id="_x0000_t75" coordsize="21600,21600" o:spt="75" o:preferrelative="t"
 path="m@4@5l@4@11@9@11@9@5xe" filled="f" stroked="f">
 <v:stroke joinstyle="miter"/>
 <v:formulas>
  <v:f eqn="if lineDrawn pixelLineWidth 0"/>
  <v:f eqn="sum @0 1 0"/>
  <v:f eqn="sum 0 0 @1"/>
  <v:f eqn="prod @2 1 2"/>
  <v:f eqn="prod @3 21600 pixelWidth"/>
  <v:f eqn="prod @3 21600 pixelHeight"/>
  <v:f eqn="sum @0 0 1"/>
  <v:f eqn="prod @6 1 2"/>
  <v:f eqn="prod @7 21600 pixelWidth"/>
  <v:f eqn="sum @8 21600 0"/>
  <v:f eqn="prod @7 21600 pixelHeight"/>
  <v:f eqn="sum @10 21600 0"/>
 </v:formulas>
 <v:path o:extrusionok="f" gradientshapeok="t" o:connecttype="rect"/>
 <o:lock v:ext="edit" aspectratio="t"/>
</v:shapetype><v:shape id="_x0000_i1025" type="#_x0000_t75" style='width:481.5pt;
 height:85.5pt'>
 <v:imagedata src="6%20СТРОКИ.files/image001.gif" o:title="75"/>
</v:shape><![endif]--><![if !vml]><img width=642 height=114
src="6%20СТРОКИ.files/image001.gif" v:shapes="_x0000_i1025"><![endif]><o:p></o:p></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Предположим, что области памяти,
выделенные компилятором для массива </span><span lang=EN-US style='mso-ansi-language:
EN-US;mso-no-proof:yes'>buf</span><span style='mso-no-proof:yes'>, и строкового
литерала “</span><span lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:
yes'>String</span><span style='mso-no-proof:yes'>” смежные. Длина массива
больше длины строки, которой он инициализирован, на 5 байт – это значит, что в
них может находиться что угодно. На рисунке показано, как изменится область
памяти, содержащая строки, после вызова </span><span lang=EN-US
style='mso-ansi-language:EN-US;mso-no-proof:yes'>strcpy</span><span
style='mso-no-proof:yes'>. <o:p></o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Приведем пример функции, которая
делает в точности то же самое, что и </span><span lang=EN-US style='mso-ansi-language:
EN-US;mso-no-proof:yes'>strcpy</span><span style='mso-no-proof:yes'>:<o:p></o:p></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>user_strcpy</span>(char* <span class=SpellE>dest</span>, const
char* <span class=SpellE>src</span>)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>char</span> *result = <span class=SpellE>dest</span>;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>do</span><o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span>*<span
class=SpellE>dest</span>++ = *<span class=SpellE>src</span>;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span></span></span><span
class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>  </span></span></span><span class=GramE><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>while</span></span></span><span
class=Code><span style='font-size:12.0pt'> (*</span></span><span class=SpellE><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>src</span></span></span><span
class=Code><span style='font-size:12.0pt'>++);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>  </span><span class=SpellE>return</span> <span
class=SpellE>result</span>;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P>Копирование прекращается лишь в том случае, если в копируемой строке
<i style='mso-bidi-font-style:normal'>встречается </i>нулевой символ. Это
значит, что, если принимающая строка (буфер) имеет недостаточную длину для
приёма копируемых данных, то произойдет выход за пределы массива, что может
привести к непредсказуемым и трудно обнаружимым ошибкам.</p>

<p class=P>Другой необходимой и часто используемой функцией работы со строками,
является функция определения их длины:</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=SpellE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>size_t</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>user_<span class=GramE>strlen</span></span><span class=GramE>(</span>const
char* <span class=SpellE>src</span>)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=SpellE><span class=GramE>size_t</span></span> result = 0;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>while</span> (*<span class=SpellE>src</span>++) result++;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span></span></span><span
class=SpellE><span class=Code><span style='font-size:12.0pt'>return</span></span></span><span
class=Code><span style='font-size:12.0pt'> <span class=SpellE>result</span>;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P style='text-indent:0cm'><span style='mso-no-proof:yes'>или
аналогичная ей функция из стандартной библиотеки:<o:p></o:p></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span class=SpellE><span class=GramE><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>size_t</span></span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>strlen</span>(const char* <span class=SpellE>src</span>);<o:p></o:p></span></span></p>

<p class=P><span lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Тип </span><span lang=EN-US
style='mso-ansi-language:EN-US;mso-no-proof:yes'>size</span><span
style='mso-no-proof:yes'>_</span><span lang=EN-US style='mso-ansi-language:
EN-US;mso-no-proof:yes'>t</span><span style='mso-no-proof:yes'> определен в </span><span
lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:yes'>string</span><span
style='mso-no-proof:yes'>.</span><span lang=EN-US style='mso-ansi-language:
EN-US;mso-no-proof:yes'>h</span><span style='mso-no-proof:yes'> и представляет
собой псевдоним целого </span>типа без знака.</p>

<p class=P>Из всего сказанного видно, что использовать операторы присваивания и
сложения для копирования и конкатенации строк (как это делалось в языке <span
lang=EN-US style='mso-ansi-language:EN-US'>Pascal</span>) нельзя:</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>
*str1 = “</span></span><span class=Code><span style='font-size:12.0pt'>Студент</span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>”;<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>
*str2 = “ </span></span><span class=Code><span style='font-size:12.0pt'>БГУИР</span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>”;<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>
*str3;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>str3 = str1 + str2; // </span></span><span class=Code><span
style='font-size:12.0pt'>НЕ</span></span><span class=Code><span
style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>верно</span></span><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>!<o:p></o:p></span></span></p>

<p class=P><span lang=EN-US style='mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></p>

<p class=P>В данном случае выражение <span class=Code><span style='font-size:
12.0pt'>str1 + str2</span></span> даже не будет скомпилировано, компилятор
выдаст ошибку: «Неверное использование указателей». Действительно, пусть строка
«Студент» находится в памяти, например, по адресу 1000, а «БГУИР» 1009.
Арифметическая сумма этих чисел даст 2009. Что <span class=GramE>находится</span>
по этому адресу сказать нельзя. Присваивание же <span class=SpellE><span
lang=EN-US style='mso-ansi-language:EN-US'>str</span></span>3 адреса строки
приведет к тому, что оба указателя будут указывать на одну и ту же область в
памяти, и изменение строки <span class=Code><span style='font-size:12.0pt'>str3</span></span>
повлечет за собой соответствующее изменение <span class=Code><span
style='font-size:12.0pt'>str1</span></span> и <span class=Code><span
style='font-size:12.0pt'>str2</span></span>, чего пользователь явно не ожидает.
Выражение</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>str3 = “Студент” + “
БГУИР”;<o:p></o:p></span></span></p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P style='text-indent:0cm'>по сути, ничем не отличается от <span
class=Code><span style='font-size:12.0pt'>str3 = str1 + str2</span></span>:
строковые литералы размещаются в памяти по адресам, которые вместо них
компилятор подставит в выражение, а складывать два адреса нельзя.</p>

<p class=P>С другой стороны, в стандартной библиотеке <span lang=EN-US
style='mso-ansi-language:EN-US'>string</span>.<span lang=EN-US
style='mso-ansi-language:EN-US'>h</span>, есть целый набор функций работы со
строками. Рассмотрим некоторые из них:</p>

<p class=P><o:p>&nbsp;</o:p></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>// Прототип функции
конкатенации строк<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>char</span></span></span><span
class=Code><span style='font-size:12.0pt'>* <span class=SpellE>strcat</span>(<span
class=SpellE>char</span>* <span class=SpellE>dest</span>, <span class=SpellE>const</span>
<span class=SpellE>char</span>* <span class=SpellE>src</span>);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>// </span></span><span class=Code><span
style='font-size:12.0pt'>Пользовательская</span></span><span class=Code><span
style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>реализация</span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'><o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>user_strcat</span>(char* <span class=SpellE>dest</span>, const
char* <span class=SpellE>src</span>)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=DE style='font-size:12.0pt;mso-ansi-language:
DE'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=DE style='font-size:12.0pt;mso-ansi-language:
DE'><span style='mso-spacerun:yes'>  </span><span class=SpellE>strcpy</span>(<span
class=SpellE>dest</span> + strlen(dest), src);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=DE style='font-size:12.0pt;mso-ansi-language:
DE'><span style='mso-spacerun:yes'>  </span></span></span><span class=SpellE><span
class=Code><span style='font-size:12.0pt'>return</span></span></span><span
class=Code><span style='font-size:12.0pt'> <span class=SpellE>dest</span>;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>// Прототип функции
поиска первого вхождения символа<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>strchr</span>(char* s, <span class=SpellE>int</span> c);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>// Пользовательская
реализация<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>char</span></span></span><span
class=Code><span style='font-size:12.0pt'>* <span class=SpellE>user_strchr</span>(<span
class=SpellE>char</span>* <span class=SpellE>s</span>, <span class=SpellE>int</span>
<span class=SpellE>c</span>)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>do</span><o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span><span
class=GramE>if</span> (*s == c) return s;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span></span></span><span
class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>  </span><span class=SpellE>while</span> (*<span
class=SpellE>s++</span>);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>  </span><span class=SpellE>return</span> 0;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>// Прототип функции
создания дубликата строки<o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>strdup</span>(const char* s);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>// Пользовательская
реализация<o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=Code><span style='font-size:12.0pt'>char</span></span></span><span
class=Code><span style='font-size:12.0pt'>* <span class=SpellE>user_strdup</span>(<span
class=SpellE>const</span> <span class=SpellE>char</span>* <span class=SpellE>s</span>);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>  </span>/* <span class=SpellE>malloc</span> – функция
динамического выделения<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>     </span>памяти, рассматривается в главе указатели
*/<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'><span
style='mso-spacerun:yes'>  </span></span></span><span class=GramE><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>return</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>strcpy</span>((char *) <span class=SpellE>malloc</span>(<span
class=SpellE>strlen</span>(s)+1), s);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>// </span></span><span class=Code><span
style='font-size:12.0pt'>Использование</span></span><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>strdup</span><o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>some_function</span>(const char* <span class=SpellE>str</span>)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>char</span>* temp = <span class=SpellE>strdup</span>(<span
class=SpellE>str</span>);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span>// ...<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>free<span lang=RU style='mso-ansi-language:RU'>(</span></span>temp</span></span><span
class=Code><span style='font-size:12.0pt'>); //Обязательное освобождение памяти!<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Среди прочих, особо нужно выделить
функцию </span><span lang=EN-US style='mso-ansi-language:EN-US;mso-no-proof:
yes'>strcmp</span><span style='mso-no-proof:yes'>. Она, в качестве параметров,
получает два указателя на строки, а возвращает 0 (ноль), если строки
(лексикографически) равны, отрицательное число, если первая строка меньше
второй, и положительное число в противном случае:<o:p></o:p></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>// </span></span><span class=Code><span
style='font-size:12.0pt'>Прототип</span></span><span class=Code><span
style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>функции</span></span><span
class=Code><span style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>сравнения</span></span><span
class=Code><span style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>строк</span></span><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'><o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=GramE><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>int</span></span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>strcmp</span>(const char* s1, const char* s2);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>// </span></span><span class=Code><span
style='font-size:12.0pt'>Пользовательская</span></span><span class=Code><span
style='font-size:12.0pt;mso-ansi-language:EN-US'> </span></span><span
class=Code><span style='font-size:12.0pt'>реализация</span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'><o:p></o:p></span></span></p>

<p class=P><span class=SpellE><span class=GramE><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>int</span></span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>user_strcmp</span>(const char* s1, const char* s2)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=SpellE><span class=GramE>int</span></span> r;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>do</span><o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>    </span>r = *s1 -
*s2;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>while</span> (*s1++ &amp;&amp; *s2++ &amp;&amp; !r);<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=GramE>return</span> r;<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>}<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><o:p>&nbsp;</o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>// </span></span><span class=Code><span
style='font-size:12.0pt'>Использование</span></span><span class=Code><span
lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'> <span
class=SpellE>strcmp</span><o:p></o:p></span></span></p>

<p class=P><span class=GramE><span class=Code><span lang=EN-US
style='font-size:12.0pt;mso-ansi-language:EN-US'>char</span></span></span><span
class=Code><span lang=EN-US style='font-size:12.0pt;mso-ansi-language:EN-US'>* <span
class=SpellE>some_function</span>(char* str1, char* str2, char* str3)<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'>{<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=SpellE><span class=GramE>printf</span></span><span class=GramE>(</span>&quot;\<span
class=SpellE>n%d</span>&quot;, <span class=SpellE>strcmp</span>(str1, str2));<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=SpellE><span class=GramE>printf</span></span><span class=GramE>(</span>&quot;\<span
class=SpellE>n%d</span>&quot;, <span class=SpellE>strcmp</span>(str2, str1));<o:p></o:p></span></span></p>

<p class=P><span class=Code><span lang=EN-US style='font-size:12.0pt;
mso-ansi-language:EN-US'><span style='mso-spacerun:yes'>  </span><span
class=SpellE><span class=GramE>printf</span></span><span class=GramE>(</span>&quot;\<span
class=SpellE>n%d</span>&quot;, <span class=SpellE>strcmp</span>(str1, str1));<o:p></o:p></span></span></p>

<p class=P><span class=Code><span style='font-size:12.0pt'>}<o:p></o:p></span></span></p>

<p class=P><span style='mso-no-proof:yes'><o:p>&nbsp;</o:p></span></p>

<p class=P><span style='mso-no-proof:yes'>Равно как и в случае других библиотек
предпочтительно использование стандартных функций работы со строками. По
сравнению с приведенными выше аналогами они намного быстрей, т.к. написаны на
языке ассемблера и оптимизированы с учетом особенностей платформы применения.<o:p></o:p></span></p>

</div>

</body>

</html>
